package com.ibm.ot4i.ace.pipeline.demo.tea;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import com.ibm.integration.test.v1.NodeSpy;
import com.ibm.integration.test.v1.NodeStub;
import com.ibm.integration.test.v1.SpyObjectReference;
import com.ibm.integration.test.v1.TestMessageAssembly;
import com.ibm.integration.test.v1.TestSetup;
import com.ibm.integration.test.v1.exception.TestException;

import static com.ibm.integration.test.v1.Matchers.*;
import static net.javacrumbs.jsonunit.JsonMatchers.jsonEquals;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThrows;
import static org.junit.Assert.assertTrue;

public class TeaRESTApplication_WholeFlow_MockDB_Tests {

        /*
         * TeaRESTApplication_getIndex_subflow_0001_Test
         * Test generated by IBM App Connect Enterprise Toolkit 12.0.1.0 on 10-Jun-2021 12:48:56
         */

        @AfterEach
        public void cleanupTest() throws TestException {
                // Ensure any mocks created by a test are cleared after the test runs 
                TestSetup.restoreAllMocks();
        }
    	@ParameterizedTest
    	//           Input Message                      Mock message                        Expected reply message
        @CsvSource({"000963D9-68D6C934-00000002-0.mxml, 000963D9-68D6C934-00000002-6.mxml,  000963D9-68D6C934-00000002-14.mxml"})
        public void TeaRESTApplication_WholeFlow_Get_Test(String inputMXMLName, String mockMXMLName, String replyMXMLName) throws TestException {

    		// Define the SpyObjectReference objects
    		SpyObjectReference httpInputObjRef = new SpyObjectReference().application("TeaRESTApplication")
    				.messageFlow("gen.TeaRESTApplication").node("HTTP Input");
    		SpyObjectReference httpReplyObjRef = new SpyObjectReference().application("TeaRESTApplication")
    				.messageFlow("gen.TeaRESTApplication").node("HTTP Reply");

    		// Initialise NodeSpy objects
    		NodeSpy httpInputSpy = new NodeSpy(httpInputObjRef);
    		NodeSpy httpReplySpy = new NodeSpy(httpReplyObjRef);
    		
    		
    		SpyObjectReference getDBrecordObjRef = new SpyObjectReference().application("TeaRESTApplication")
    				.messageFlow("gen.TeaRESTApplication").subflowNode("getIndex (Implementation)")
    				.subflowNode("getIndexImpl").subflowNode("GetFromDB").node("Get DB record");
     		NodeStub getDBrecordStub = new NodeStub(getDBrecordObjRef);
    				
    		
		    // Program the stub to return this dummy result instead of calling the service
		    TestMessageAssembly getDBrecordMessage = new TestMessageAssembly();
    		getDBrecordMessage.buildFromRecordedMessageAssembly(Thread.currentThread().getContextClassLoader()
        			.getResourceAsStream(mockMXMLName));
    		getDBrecordStub.onCall().propagatesMessage("in", "out", getDBrecordMessage);
    
    
            // Declare a new TestMessageAssembly object for the message being sent into the node
            TestMessageAssembly inputMessageAssembly = new TestMessageAssembly();
            InputStream inputMessage = Thread.currentThread().getContextClassLoader().getResourceAsStream(inputMXMLName);
            inputMessageAssembly.buildFromRecordedMessageAssembly(inputMessage);

    		// Configure the "in" terminal on the HTTP Reply node not to propagate.
    		// If we don't do this, then the reply node will throw exceptions when it  
    		// realises we haven't actually used the HTTP transport.
    		httpReplySpy.setStopAtInputTerminal("in");

    		// Now call propagate on the "out" terminal of the HTTP Input node.
    		// This takes the place of an actual HTTP message: we simple hand the node
    		// the message assembly and tell it to propagate that as if it came from an
    		// actual client. This line is where the flow is actually run.
    		httpInputSpy.propagate(inputMessageAssembly, "out");
    		
    		// Note that any exceptions would cause this test to fail, so if we reach 
    		// the next lines then the flow has completed successfully.
    		
    		// Validate the results from the flow execution
            // We will now pick up the message that is propagated into the "HttpReply" node and validate it
    		TestMessageAssembly replyMessageAssembly = httpReplySpy.receivedMessageAssembly("in", 1);

			// Assert output message body data
			// Get the TestMessageAssembly object for the expected propagated message
    		TestMessageAssembly expectedMessageAssembly = new TestMessageAssembly();
            InputStream expectedMessage = Thread.currentThread().getContextClassLoader().getResourceAsStream(replyMXMLName);
            expectedMessageAssembly.buildFromRecordedMessageAssembly(expectedMessage);

            // Check the reply is as expected
            assertThat(replyMessageAssembly, equalsMessage(expectedMessageAssembly).ignorePath("/HTTPReplyHeader/Server_Hostname", false));
    }
}